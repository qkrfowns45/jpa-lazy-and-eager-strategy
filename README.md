# jpa-lazy-and-eager-strategy
jpa에서 eager보다 lazy를 사용해 n+1문제를 해결하는 방법

## 즉시 로딩(EAGER)
> fetchType을 EAGER로 설정하면 된다.
> 대부분의 JPA구현체는 가능하면 조인을 사용해서 SQL을 한번에 함께 조회하려고 한다. 이렇게 하면 실제 조회할 때 한방 쿼리로 다 조회해온다.
> 실행 결과 또한 프록시 객체가 아닌 실제 객체이다. 그러나 이렇게 즉시 로딩 전략을 사용하면 여러 문제들을 가져오기 때문에 실무에서는 쓰지 않는 것이 좋다.
+ 예상하지 못한 SQL 발생!!
 > 실무에서는 무수히 많은 테이블들이 존재하고 @ManyToOne이라도 쓰게 되면 연관된 많은 테이블들이 조인하게 된다.
+ JPQL에서 N+1문제를 일으킨다!!
 > 실무에서는 복잡한 쿼리를 많이 풀어내기 위해 JPQL을 많이 사용한다.
 > JPQL에서는 입력 받은 query string이 그대로 sql로 변환된다.
 > 이때 fetchType이 EAGER면 LAZY면 프록시를 영속성 컨텍스트에 넣지만 EAGER는 반환하는 시점에 다 조회가 되어 있어야 하고 기본 정보에서 연관된 정보를 다시 다 가져온다
 > 이때 만약 가져오는 데이터 양이 수만이라면 감당하기 어려울 것이다.
 > 이처럼 N+1은 1개의 쿼리를 날렸는데 추가 쿼리 N개가 나간다는 의미다.
 
 ## 지연 로딩(LAZY)
 > EAGER와는 다르게 LAZY로 선언되면 기본 정보와 나머지 연관 정보들은 프록시(빈 객체)로 영속성 컨텍스트에 저장된다.
 > 후에 실제 객체를 사용하는 시점에 초기화가 되고 DB에 쿼리가 나간다.
 > 물론 짧은 조회들은 실행하면 한번에 조회하면 되기 때문에 손해지만 실무에서 대용량 테이블들이 많기 때문에 LAZY를 선호한다.
 > 대분의 JPA 구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회하려고 한다.
 > 이렇게 하면, 실제 조회할 때 한방 쿼리로 다 조회해온다.
 > 실행 결과 또한 객체도 프록시 객체가 아니라 실제 객체이다.
 
 ## JPA의 OSIV 전략
 > application.yml에서 jpa의 open-in-view를 true하면 lazy 전략이 가능하게 된다. 영속성을 프레젠테이션 계층까지 가져가게 된다. 트랜잭션은 서비스 계층에서 종료되고
 > controller의 session이 close되지 않았기 때문에, 영속 객체는 영속상태를 유지 할 수 있고 프록시 객체에 대한 LAZY LOADING을 수행할 수 있다.
 > 버전 2.0부터 스프링 부트는 기본적으로 OSIV가 활성화 되어있을 때 경고를 발행하므로 프로덕션 시스템에 영향을 주기 전에 이 문제를 발견 할 수 있다.
 > 서블릿 필터에서 session을 오픈하고 트랜잭션을 시작하던 전통적인 방식의 OPEN SESSION IN VIEW패턴과 달리 SPRINGMVC에서 제공하는 OpenSessionViewFilter는 필터 내에서 Session은
 > 오픈하지만 트랜잭션은 시작하지 않는다. 따라서 서블릿 필터 안에서는 커넥션 풀로부터 JDBC커넥션을 얻을 필요가 없다.
